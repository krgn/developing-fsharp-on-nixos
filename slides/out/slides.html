<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Karsten Gebbert">
  <meta name="dcterms.date" content="2015-12-10">
  <title>Developing F# on NixOS</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Developing F# on NixOS</h1>
    <h2 class="author">Karsten Gebbert</h2>
    <h3 class="date">27/10/2015</h3>
</section>

<section><section id="hi." class="titleslide slide level1"><h1>Hi.</h1></section><h4 id="introductions">Introductions</h4><section class="slide level2">

<h3 id="who-why">Who? Why?</h3>
<ul>
<li class="fragment">I am not a Nix(OS) or F# expert or .NET veteran</li>
<li class="fragment">this talk is aimed at people with experience level roughly to my own</li>
<li class="fragment">sharing my personal experience and impressions</li>
<li class="fragment">it is my first talk, so please criticize me (gently :))</li>
</ul>
<aside class="notes">
<p>Introductions:</p>
<ul>
<li>introduce yourself</li>
<li>work @ nsynk GmbH</li>
<li>my background in arts, music, computing</li>
<li>interests
<ul>
<li>functional programming</li>
<li>systems programming</li>
<li>distributed systems</li>
<li>web</li>
<li>audio/video</li>
</ul></li>
<li>a few words about iris
<ul>
<li>distributed system of VVVV renderers</li>
<li>used for playback of high-quality (4K) video streams, potentially with 3d rendered overlays and integration with all kinds of other systems (sensors, kinetics etc)</li>
<li>IAA</li>
</ul></li>
<li>my usage of NixOS
<ul>
<li>mainly as a development platform</li>
<li>use VMs for Windows-based work</li>
</ul></li>
</ul>
</aside>
</section><section class="slide level2">

<h3 id="what">What?</h3>
<ul>
<li class="fragment">explore some basic aspects of F#</li>
<li class="fragment">look at a library for creating http services, Suave.IO</li>
<li class="fragment">give an overview over recoll, a file indexer</li>
<li class="fragment">construct a small service to query recoll via HTTP</li>
<li class="fragment">deploy that service using nix</li>
</ul>
</section></section>
<section><section id="what-is-f" class="titleslide slide level1"><h1>What is F#?</h1></section><h4 id="f">F#</h4><section class="slide level2">

<blockquote>
<p>F# was developed in 2005 at Microsoft Research[1]. In many ways, F# is essentially a .Net implementation of OCaml, combining the power and expressive syntax of functional programming with the tens of thousands of classes which make up the .NET class library.</p>
</blockquote>
</section><section class="slide level2">

<h4 id="overview">Overview</h4>
<ul>
<li class="fragment">functional-first CLI programming language in the ML family</li>
<li class="fragment">object-orientation</li>
<li class="fragment">the 'm'-word (look at the computation-food paper that I downloaded)</li>
<li class="fragment">ecosystem seems somewhat fragmented, but there are many useful libraries out there</li>
</ul>
<aside class="notes">

</aside>
</section><section class="slide level2">

<h4 id="pros">Pros:</h4>
<ul>
<li class="fragment">For those who (have to) write software for the CLR its a solid choice</li>
<li class="fragment">With projects like WebSharper or FunScript, F# can be used throughout the whole stack (share types and code, thus safety)</li>
<li class="fragment">Interop wth C# works really well, and there are lots of good libraries</li>
<li class="fragment">its essentially a really good blend between the principled and utilitarian mind-sets</li>
</ul>
<aside class="notes">
<ul>
<li>WARNING: highly subjective</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="cons">Cons:</h4>
<ul>
<li class="fragment">it introduces new nomenclature for common fp concepts (monads), to create a more clear distinction to other languages, which confused me more than it helped</li>
<li class="fragment">TODO: find out differences in the type systems</li>
<li class="fragment">no GADTs</li>
<li class="fragment">while OO has some points to go for it (think familiarity to large audiences of developers, generally well understood) it is a bit ugly and alien in this context.</li>
</ul>
<aside class="notes">
<ul>
<li>again, WARNING: highly subjective!</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="differences-from-haskell">Differences from Haskell</h4>
<ul>
<li class="fragment">TODO: list up different operators</li>
<li class="fragment">TODO: explain fixity rules</li>
<li class="fragment">TODO: show a small implementation of a ComputationBuilder</li>
</ul>
<ul>
<li class="fragment">impure: <em>launchMissiles ()</em> whereever you feel like it</li>
<li class="fragment">no <code>where</code></li>
</ul>
</section><section class="slide level2">

<h4 id="lets-look-at-some-code">Let's look at some code</h4>
</section><section class="slide level2">

<h4 id="the-λ-calculus">The λ-calculus</h4>
<pre class="fsharp fragment"><code>// variable binding
let x = 41</code></pre>
<pre class="fsharp fragment"><code>// functions
let f = fun (value : int) -&gt; value + 1</code></pre>
<pre class="fsharp fragment"><code>let f value = value + 1 // shorter</code></pre>
<pre class="fsharp fragment"><code>let f = (+) 1 // partially applied</code></pre>
<pre class="fsharp fragment"><code>// function application
f x</code></pre>
<pre class="fsharp fragment"><code>// a common idiom in F# is the `apply to` operator
x |&gt; f</code></pre>
<aside class="notes">
<p>VARIABLE BINDING</p>
<ul>
<li>for me &quot;seeing is believing&quot;</li>
<li>all statements are bound using <code>let</code></li>
<li>mention <code>let .. in</code></li>
<li>talk about the type annotation</li>
<li>Not my absolute super-favourite programming language, but certainly a <em>very</em> good one.</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="types">Types</h4>
<pre class="fsharp fragment"><code>// a binary tree - example of a sum type
type Tree&lt;&#39;a&gt; =
  | Node of Tree&lt;&#39;a&gt; * int * Tree&lt;&#39;a&gt;
  | Leaf of &#39;a</code></pre>
<pre class="fsharp fragment"><code>// another &quot;discriminated union&quot; for modeling state changes in an application
type AppAction =
  | AddThing
  | EditThing
  | RemoveThing</code></pre>
<pre class="fsharp fragment"><code>// record - a product type
type Person = { name : string; age : int }</code></pre>
<pre class="fsharp fragment"><code>// optional (aka. Maybe)
type option&lt;&#39;a&gt; =
  | Some of &#39;a
  | None</code></pre>
<pre class="fsharp fragment"><code>// type alias
type Person = (int, string)</code></pre>
</section><section class="slide level2">

<h4 id="classes">Classes</h4>
<pre class="fsharp"><code>// Objects o.O
type Person (a: int, n: string) =
  let mutable name = n
  let mutable age = a

  member self.Name          // properties
    with get () = name      // getter -&gt;
     and set n  = name &lt;- n // setter &lt;-

  member self.Age
    with get () = age
     and set a  = age &lt;- a

  member self.OldEnough () = age &gt; 18

  static member Greet () = printfn &quot;Hi.&quot;

// usage
let me = new Person (34, &quot;Karsten&quot;)
me.OldEnough ()</code></pre>
<aside class="notes">
<ul>
<li>method invokation is confusing, because args are esseentially passed as a n-tuplet</li>
<li>let-bound variables are private</li>
<li>mutability is simble, if somewhat verbose</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="pattern-matching">Pattern Matching</h4>
<pre class="fsharp"><code>let horse : string option = Some &quot;Hi.&quot;

// handling all cases with match
match f with
  | Some &quot;Hello.&quot; -&gt; printfn &quot;it said hello.&quot;
  | Some &quot;Hi.&quot;    -&gt; printfn &quot;it said hi.&quot;
  | Some _        -&gt; printfn &quot;it said something else.&quot;
  | None          -&gt; printfn &quot;it does not speak.&quot;</code></pre>
<pre class="fsharp fragment"><code>TODO more examples for PM</code></pre>
<aside class="notes">
<ul>
<li>useful for producing total code</li>
<li>types of pattern matching that are possible is long</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="modules-and-..">Modules and ..</h4>
<pre class="fsharp"><code>// declare a module locally
module MyTree = 
  // indent!
  type Tree&lt;&#39;a&gt; =
    | Node of Tree&lt;&#39;a&gt; * &#39;a * Tree&lt;&#39;a&gt;
    | Leaf</code></pre>
<pre class="fsharp fragment"><code>// top-level definition
module MyTree

(*
  - declare at the top of file
  - no =
  - no indentation!
*)
let testTree depth =
  let rec testTree&#39; current max =
    let next = current + 1
    if current = (max - 1)
    then Node(Leaf, current, Leaf)
    else Node(testTree&#39; next max, current, testTree&#39; next max)
  testTree&#39; 0 depth</code></pre>
</section><section class="slide level2">

<h4 id="namespaces">.. Namespaces</h4>
<pre class="fsharp fragment"><code>namespace Data

module MyTree =
  // no indentation!
  type Tree&lt;&#39;a&gt; =
    | Node of Tree&lt;&#39;a&gt; * int * Tree&lt;&#39;a&gt;
    | Leaf of &#39;a</code></pre>
<pre class="fsharp fragment"><code>// combine namespace and module into one statement
module Data.MyTree

// again, no indentation!
type Tree&lt;&#39;a&gt; =
  | Node of Tree&lt;&#39;a&gt; * int * Tree&lt;&#39;a&gt;
  | Leaf of &#39;a</code></pre>
</section><section class="slide level2">

<h4 id="other-cool-things-to-look-at">Other Cool Things To Look At</h4>
<ul>
<li class="fragment">Monads, or <em>Computation Expressions</em></li>
<li class="fragment">Quotations &amp; Reflection (metaprogramming)</li>
<li class="fragment">Units of Measure</li>
<li class="fragment">built-in support for Actor-style programming</li>
</ul>
</section><section id="f-and-nixos" class="slide level2">
<h1>F# and NixOS</h1>
</section><section class="slide level2">

<ul>
<li class="fragment">F# currently is packaged separately from mono</li>
<li class="fragment">as a consequence, there is no single GAC (Global Assembly Cache) for all .NET packages</li>
<li class="fragment">package management is traditionally done using <em>nuget</em> and an IDE front-end (this might make some people in the audience flinch)</li>
<li class="fragment"><em>paket</em> is a very promising replacement setting out to fix the common problem of <em>DLL</em> hell</li>
<li class="fragment"><em>paket</em> resolves the dependency graph at the solution level and manages references of projects</li>
</ul>
</section><section class="slide level2">

<h4 id="but-whats-the-point-of-using-nixos-then">But whats the point of using Nix(OS) then?</h4>
<pre class="fsharp fragment"><code>Tentative Answer:

because it brings a lot more value to the table than just package management!</code></pre>
</section><section class="slide level2">

<p>To use <em>nix</em> for package management we'd need to:</p>
<ol type="1">
<li class="fragment">create and maintain packages for nuget packages, possibly automating the process with the right tooling</li>
<li class="fragment">have a way to generate reference entries in .fsproj files automatically, just as <em>paket</em> does it</li>
<li class="fragment">build projects such that runtime deps get linked correctly</li>
</ol>
</section><section class="slide level2">

<ul>
<li class="fragment">some work towards that end has already been done by <span class="citation" data-cites="obadz">@obadz</span>, albeit it seems experimental at this point</li>
<li class="fragment">there might not be big enough incentives to do this at this point</li>
</ul>
<aside class="notes">
<ul>
<li>not trivial</li>
<li>as with haskell ecosystem, not exactly easy-to-use</li>
<li>haskell package management had more incentives since cabal-hell was much more of a pressing problem to haskell users</li>
<li>disagreement?</li>
<li>discussion?</li>
<li>different points of view on that matter?</li>
</ul>
</aside>
</section></section>
<section><section id="a-sample-project" class="titleslide slide level1"><h1>A Sample Project</h1></section><h4 id="project">Project</h4><section class="slide level2">

<h4 id="proposition">Proposition</h4>
<p>Assume we have a lots of great computer science papers on our SSD, and we'd like to be able to index and query for information (e.g. [1]) via <em>curl</em>.</p>
<p>So, lets build a small microservice around the <em>recoll</em> full-text indexer and serve query results via HTTP.</p>
<p>[1] https://github.com/ocharles/papers</p>
<aside class="notes">
<ul>
<li>idea could at transferred to some more relevant technology like, e.g., elasticsearch</li>
<li>from there, it might be interesting to go on to explore clustering and config management with nix</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="a-quick-word-about...">A quick word about...</h4>
</section><section class="slide level2">

<h4 id="microservices">Microservices!</h4>
</section><section class="slide level2">

<h4 id="microservies">Microservies?</h4>
<p><em>TODO</em>: remind myself WTF are they again?</p>
</section><section class="slide level2">

<p>No, but seriously, its a stupid buzzword and we all know it but apparently we like pressing those buttons over and over again.</p>
</section><section class="slide level2">

<p>A microservice is a small, stand-alone component most often part of a system of more of these stand-alone, de-coupled units.</p>
<p>Essentially, its a scalability design pattern for web applications.</p>
</section><section class="slide level2">

<p>From the point of view of a functional programming enthusiast, microservices are a good example of how small, stateless (<em>pure!</em>) building blocks (<em>referential transparency</em>) can be <em>composed</em> into systems that are easier to understand and maintain and more robust that big monolithic code-bases.</p>
</section><section class="slide level2">

<p>I am not a dev-ops person, but I hear that larger systems become fiendishly hard to deploy and monitor, though.</p>
<p>Blame successfully shifted!</p>
<p>:)</p>
<aside class="notes">

</aside>
</section><section id="bootstrapping" class="slide level2">
<h1>Bootstrapping</h1>
</section><section class="slide level2">

<p>The state of affairs of project management in mono/F# is still for the most part centered around using IDE's for everything.</p>
<aside class="notes">
<ul>
<li>quite a big annoyance</li>
</ul>
</aside>
</section><section class="slide level2">

<p>There are the obvious Candidates, such as MS' Visual Studio or MonoDevelop, which is at least free and available via <em>nix</em>.</p>
</section><section class="slide level2">

<p>To alleviate that situation for those who don't like IDEs, there is a project scaffold git repository with an initialization routine to help set up everything.</p>
</section><section class="slide level2">

<p>We'll focus on that workflow for this talk, since this be beneficial to automate tasks down the line (think CI and deployment).</p>
</section><section class="slide level2">

<h4 id="using-project-scaffold">Using Project Scaffold</h4>
<pre class="fsharp"><code>→ git clone git@github.com:fsprojects/ProjectScaffold.git PaperScraper</code></pre>
<pre class="fsharp fragment"><code>→ cd PaperScraper &amp;&amp; ./build.sh</code></pre>
</section><section class="slide level2">

<p>Answer a couple of questions and you're set. But wait!</p>
</section><section class="slide level2">

<figure>
<img src="img/splonk.jpg" alt="" />
</figure>
</section><section class="slide level2">

<p>Whats this!?!</p>
<p><code>error : Target named 'Rebuild' not found in the project.</code></p>
<h4 id="a-note-about-build-targets">A Note About Build Targets</h4>
<p><code>→ nix-env -i dotnetbuildhelpers</code></p>
</section><section class="slide level2">

<blockquote>
<p>→ patch-fsharp-targets.sh Patching F# targets in fsproj files... ./src/PaperTrail/PaperTrail.fsproj ./tests/PaperTrail.Tests/PaperTrail.Tests.fsproj</p>
</blockquote>
<p>in scripts/.bashrc etc:</p>
<blockquote>
<p>→ export FSharpTargetsPath=$(dirname $(which fsharpc))/../lib/mono/4.5/Microsoft.FSharp.Targets or → set -x FSharpTargetsPath (dirname (which fsharpc))/../lib/mono/4.5/Microsoft.FSharp.Targets</p>
</blockquote>
<p>Add an entry for it to <code>paket.dependencies</code></p>
<aside class="notes">

</aside>
</section><section id="but-were-building-an-executable-right" class="slide level2">
<h1>But we're building an executable, right?!</h1>
</section></section>
<section><section id="suave.io" class="titleslide slide level1"><h1>Suave.IO</h1></section><section id="recoll" class="slide level2">
<h1>Recoll</h1>
<ul>
<li class="fragment">full-text search tool</li>
<li class="fragment">uses xapian underneath (like other great tools, e.g. <code>notmuch</code> and <code>mu</code>)</li>
<li class="fragment">supports many file types, including extracting text from PDFs</li>
</ul>
<aside class="notes">

</aside>
</section></section>
<section><section id="deployment" class="titleslide slide level1"><h1>Deployment</h1></section><section id="writing-a-derivation" class="slide level2">
<h1>Writing a derivation</h1>
<pre><code>→ export FSharpTargetsPath=&quot;${fsharp}/lib/mono/4.5/Microsoft.FSharp.Targets&quot;</code></pre>
<aside class="notes">

</aside>
</section><section id="systemd-services" class="slide level2">
<h1>Systemd services</h1>
<ul>
<li class="fragment">need a service for the api server</li>
<li class="fragment">need a timer and service for recollindexer</li>
</ul>
<aside class="notes">

</aside>
</section><section class="slide level2">

<ul>
<li class="fragment">sending a closure</li>
<li class="fragment">container?</li>
</ul>
<aside class="notes">

</aside>
</section><section id="docker-container" class="slide level2">
<h1>Docker container????</h1>
</section><section id="trying-it-out" class="slide level2">
<h1>Trying it out</h1>
<aside class="notes">

</aside>
</section></section>
<section><section id="useful-resources" class="titleslide slide level1"><h1>Useful resources</h1></section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Vertical centering of slides
        center: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
