<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Karsten Gebbert">
  <meta name="dcterms.date" content="2015-12-10">
  <title>Developing F# on NixOS</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css"/>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
    <h1 class="title">Developing F# on NixOS</h1>
    <h2 class="author">Karsten Gebbert</h2>
    <h3 class="date">27/10/2015</h3>
</section>

<section><section id="hi." class="titleslide slide level1"><h1>Hi.</h1></section><h4 id="introductions">Introductions</h4><section class="slide level2">

<h3 id="who-why">Who? Why?</h3>
<ul>
<li class="fragment">this talk is meant as an introduction to developing F# on NixOS</li>
<li class="fragment">I am not a Nix(OS) or F# expert or .NET veteran (yet)</li>
<li class="fragment">sharing my personal experience and impressions</li>
<li class="fragment">approaches taken have a few rough edges, so please help me improve it!</li>
<li class="fragment">it is my first experience of this kind, so please do criticize me (gently)</li>
</ul>
<aside class="notes">
<p>Introductions:</p>
<ul>
<li>introduce yourself</li>
<li>work @ nsynk GmbH</li>
<li>my background in arts, music, computing</li>
<li>interests
<ul>
<li>functional programming</li>
<li>systems programming</li>
<li>distributed systems</li>
<li>web</li>
<li>audio/video</li>
</ul></li>
<li>a few words about iris
<ul>
<li>distributed system of VVVV renderers</li>
<li>used for playback of high-quality (4K) video streams, potentially with 3d rendered overlays and integration with all kinds of other systems (sensors, kinetics etc)</li>
<li>IAA</li>
</ul></li>
<li>my usage of NixOS
<ul>
<li>mainly as a development platform</li>
<li>use VMs for Windows-based work</li>
</ul></li>
</ul>
</aside>
</section><section class="slide level2">

<h3 id="what">What?</h3>
<ul>
<li class="fragment">explore some basic aspects of F#</li>
<li class="fragment">look at a library for creating http services, Suave.IO</li>
<li class="fragment">give an overview over recoll, a file indexer</li>
<li class="fragment">construct a small service to query recoll via HTTP</li>
<li class="fragment">deploy that service using nix</li>
</ul>
</section></section>
<section><section id="what-is-f" class="titleslide slide level1"><h1>What is F#?</h1></section><h4 id="f">F#</h4><section class="slide level2">

<blockquote>
<p>F# was developed in 2005 at Microsoft Research[1]. In many ways, F# is essentially a .Net implementation of OCaml, combining the power and expressive syntax of functional programming with the tens of thousands of classes which make up the .NET class library.</p>
</blockquote>
</section><section class="slide level2">

<h4 id="overview">Overview</h4>
<ul>
<li class="fragment">functional-first CLI programming language in the ML family</li>
<li class="fragment">object-orientation</li>
<li class="fragment">the 'm'-word (look at the computation-food paper that I downloaded)</li>
<li class="fragment">ecosystem seems somewhat fragmented, but there are many useful libraries out there</li>
</ul>
<aside class="notes">

</aside>
</section><section class="slide level2">

<h4 id="pros">Pros:</h4>
<ul>
<li class="fragment">For those who (have to) write software for the CLR its a solid choice</li>
<li class="fragment">With projects like WebSharper or FunScript, F# can be used throughout the whole stack (share types and code, thus safety)</li>
<li class="fragment">Interop wth C# works really well, and there are lots of good libraries</li>
<li class="fragment">its essentially a really good blend between the principled and utilitarian mind-sets</li>
</ul>
<aside class="notes">
<ul>
<li>WARNING: highly subjective</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="cons">Cons:</h4>
<ul>
<li class="fragment">it introduces new nomenclature for common fp concepts (monads), to create a more clear distinction to other languages, which confused me more than it helped</li>
<li class="fragment">TODO: find out differences in the type systems</li>
<li class="fragment">no GADTs</li>
<li class="fragment">while OO has some points to go for it (think familiarity to large audiences of developers, generally well understood) it is a bit ugly and alien in this context.</li>
</ul>
<aside class="notes">
<ul>
<li>again, WARNING: highly subjective!</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="differences-from-haskell">Differences from Haskell</h4>
<ul>
<li class="fragment">TODO: list up different operators</li>
<li class="fragment">TODO: explain fixity rules</li>
<li class="fragment">TODO: show a small implementation of a ComputationBuilder</li>
</ul>
<ul>
<li class="fragment">impure: <em>launchMissiles ()</em> whereever you feel like it</li>
<li class="fragment">no <code>where</code></li>
</ul>
</section><section class="slide level2">

<h4 id="lets-look-at-some-code">Let's look at some code</h4>
</section><section class="slide level2">

<h4 id="the-λ-calculus">The λ-calculus</h4>
<pre class="fsharp fragment"><code>// variable binding
let x = 41</code></pre>
<pre class="fsharp fragment"><code>// functions
let f = fun (value : int) -&gt; value + 1</code></pre>
<pre class="fsharp fragment"><code>let f value = value + 1 // shorter</code></pre>
<pre class="fsharp fragment"><code>let f = (+) 1 // partially applied</code></pre>
<pre class="fsharp fragment"><code>// function application
f x</code></pre>
<pre class="fsharp fragment"><code>// a common idiom in F# is the `apply to` operator
x |&gt; f</code></pre>
<aside class="notes">
<p>VARIABLE BINDING</p>
<ul>
<li>for me &quot;seeing is believing&quot;</li>
<li>all statements are bound using <code>let</code></li>
<li>mention <code>let .. in</code></li>
<li>talk about the type annotation</li>
<li>Not my absolute super-favourite programming language, but certainly a <em>very</em> good one.</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="types">Types</h4>
<pre class="fsharp fragment"><code>// a binary tree - example of a sum type
type Tree&lt;&#39;a&gt; =
  | Node of Tree&lt;&#39;a&gt; * int * Tree&lt;&#39;a&gt;
  | Leaf of &#39;a</code></pre>
<pre class="fsharp fragment"><code>// another &quot;discriminated union&quot; for modeling state changes in an application
type AppAction =
  | AddThing
  | EditThing
  | RemoveThing</code></pre>
<pre class="fsharp fragment"><code>// record - a product type
type Person = { name : string; age : int }</code></pre>
<pre class="fsharp fragment"><code>// optional (aka. Maybe)
type option&lt;&#39;a&gt; =
  | Some of &#39;a
  | None</code></pre>
<pre class="fsharp fragment"><code>// type alias
type Person = (int, string)</code></pre>
</section><section class="slide level2">

<h4 id="classes">Classes</h4>
<pre class="fsharp"><code>// Objects o.O
type Person (a: int, n: string) =
  let mutable name = n
  let mutable age = a

  member self.Name          // properties
    with get () = name      // getter -&gt;
     and set n  = name &lt;- n // setter &lt;-

  member self.Age
    with get () = age
     and set a  = age &lt;- a

  member self.OldEnough () = age &gt; 18

  static member Greet () = printfn &quot;Hi.&quot;

// usage
let me = new Person (34, &quot;Karsten&quot;)
me.OldEnough ()</code></pre>
<aside class="notes">
<ul>
<li>method invokation is confusing, because args are esseentially passed as a n-tuplet</li>
<li>let-bound variables are private</li>
<li>mutability is simble, if somewhat verbose</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="pattern-matching">Pattern Matching</h4>
<pre class="fsharp"><code>let horse : string option = Some &quot;Hi.&quot;

// handling all cases with match
match f with
  | Some &quot;Hello.&quot; -&gt; printfn &quot;it said hello.&quot;
  | Some &quot;Hi.&quot;    -&gt; printfn &quot;it said hi.&quot;
  | Some _        -&gt; printfn &quot;it said something else.&quot;
  | None          -&gt; printfn &quot;it does not speak.&quot;</code></pre>
<pre class="fsharp fragment"><code>TODO more examples for PM</code></pre>
<aside class="notes">
<ul>
<li>useful for producing total code</li>
<li>types of pattern matching that are possible is long</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="modules-and-..">Modules and ..</h4>
<pre class="fsharp"><code>// declare a module locally
module MyTree = 
  // indent!
  type Tree&lt;&#39;a&gt; =
    | Node of Tree&lt;&#39;a&gt; * &#39;a * Tree&lt;&#39;a&gt;
    | Leaf</code></pre>
<pre class="fsharp fragment"><code>// top-level definition
module MyTree

(*
  - declare at the top of file
  - no =
  - no indentation!
*)
let testTree depth =
  let rec testTree&#39; current max =
    let next = current + 1
    if current = (max - 1)
    then Node(Leaf, current, Leaf)
    else Node(testTree&#39; next max, current, testTree&#39; next max)
  testTree&#39; 0 depth</code></pre>
</section><section class="slide level2">

<h4 id="namespaces">.. Namespaces</h4>
<pre class="fsharp fragment"><code>namespace Data

module MyTree =
  // no indentation!
  type Tree&lt;&#39;a&gt; =
    | Node of Tree&lt;&#39;a&gt; * int * Tree&lt;&#39;a&gt;
    | Leaf of &#39;a</code></pre>
<pre class="fsharp fragment"><code>// combine namespace and module into one statement
module Data.MyTree

// again, no indentation!
type Tree&lt;&#39;a&gt; =
  | Node of Tree&lt;&#39;a&gt; * int * Tree&lt;&#39;a&gt;
  | Leaf of &#39;a</code></pre>
</section><section class="slide level2">

<h4 id="other-cool-things-to-look-at">Other Cool Things To Look At</h4>
<ul>
<li class="fragment">Type Providers</li>
<li class="fragment">Monads, or <em>Computation Expressions</em></li>
<li class="fragment">Quotations &amp; Reflection (metaprogramming)</li>
<li class="fragment">Units of Measure</li>
<li class="fragment">built-in support for Actor-style programming</li>
</ul>
</section><section id="f-and-nixos" class="slide level2">
<h1>F# and NixOS</h1>
</section><section class="slide level2">

<ul>
<li class="fragment">F# currently is packaged separately from mono</li>
<li class="fragment">as a consequence, there is no single GAC (Global Assembly Cache) for all .NET packages</li>
<li class="fragment">package management is traditionally done using <em>nuget</em> and an IDE front-end (this might make some people in the audience flinch)</li>
<li class="fragment"><em>paket</em> is a very promising replacement setting out to fix the common problem of <em>DLL</em> hell</li>
<li class="fragment"><em>paket</em> resolves the dependency graph at the solution level and manages references of projects</li>
</ul>
</section><section class="slide level2">

<h4 id="but-whats-the-point-of-using-nixos-then">But whats the point of using Nix(OS) then?</h4>
<pre class="fsharp fragment"><code>Tentative Answer:

because it brings a lot more value to the table than just package management!</code></pre>
</section><section class="slide level2">

<p>To use <em>nix</em> for package management we'd need to:</p>
<ol type="1">
<li class="fragment">create and maintain packages for nuget packages, possibly automating the process with the right tooling</li>
<li class="fragment">have a way to generate reference entries in .fsproj files automatically, just as <em>paket</em> does it</li>
<li class="fragment">build projects such that runtime deps get linked correctly</li>
</ol>
</section><section class="slide level2">

<ul>
<li class="fragment">some work towards that end has already been done by <span class="citation" data-cites="obadz">@obadz</span>, albeit it seems experimental at this point</li>
<li class="fragment">there might not be big enough incentives to do this at this point</li>
</ul>
<aside class="notes">
<ul>
<li>not trivial</li>
<li>as with haskell ecosystem, not exactly easy-to-use</li>
<li>haskell package management had more incentives since cabal-hell was much more of a pressing problem to haskell users</li>
<li>disagreement?</li>
<li>discussion?</li>
<li>different points of view on that matter?</li>
</ul>
</aside>
</section></section>
<section><section id="a-sample-project" class="titleslide slide level1"><h1>A Sample Project</h1></section><h4 id="project">Project</h4><section class="slide level2">

<h4 id="proposition">Proposition</h4>
<p>Assume we have a lots of great computer science papers on our SSD, and we'd like to be able to index and query for information (e.g. [1]) via <em>curl</em>.</p>
<p>So, lets build a small microservice around the <em>recoll</em> full-text indexer and serve query results via HTTP.</p>
<p>[1] https://github.com/ocharles/papers</p>
<aside class="notes">
<ul>
<li>idea could at transferred to some more relevant technology like, e.g., <em>elasticsearch</em></li>
<li>from there, it might be interesting to go on to explore clustering and config management with nix</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="a-quick-word-about...">A quick word about...</h4>
</section><section class="slide level2">

<h4 id="microservices">Microservices!</h4>
</section><section class="slide level2">

<h4 id="microservies">Microservies?</h4>
<p><em>TODO</em>: remind myself WTF are they again?</p>
</section><section class="slide level2">

<p>No, but seriously, its a stupid buzzword and we all know it but apparently we like pressing those buttons over and over again.</p>
</section><section class="slide level2">

<p>A microservice is a small, stand-alone component most often part of a system of more of these stand-alone, de-coupled units.</p>
<p>Essentially, its a scalability design pattern for web applications.</p>
</section><section class="slide level2">

<p>From the point of view of a functional programming enthusiast, microservices are a good example of how small, stateless (<em>pure!</em>) building blocks (<em>referential transparency</em>) can be <em>composed</em> into systems that are easier to understand and maintain and more robust that big monolithic code-bases.</p>
</section><section class="slide level2">

<p>I am not a dev-ops person, but I hear that larger systems become fiendishly hard to deploy and monitor, though.</p>
<p>Blame successfully shifted!</p>
<p>:)</p>
<aside class="notes">

</aside>
</section><section id="bootstrapping" class="slide level2">
<h1>Bootstrapping</h1>
</section><section class="slide level2">

<p>The state of affairs of project management in mono/F# is still for the most part centered around using IDE's for everything.</p>
<aside class="notes">
<ul>
<li>quite a big annoyance</li>
</ul>
</aside>
</section><section class="slide level2">

<p>There are the obvious Candidates, such as MS' Visual Studio or MonoDevelop, which is at least free and available via <em>nix</em>.</p>
</section><section class="slide level2">

<p>To alleviate that situation for those who don't like IDEs, there is a project scaffold git repository with an initialization routine to help set up everything.</p>
</section><section class="slide level2">

<p>We'll focus on that workflow for this talk, since this be beneficial to automate tasks down the line (think CI and deployment).</p>
</section><section class="slide level2">

<h4 id="using-project-scaffold">Using Project Scaffold</h4>
<pre class="fsharp"><code>→ git clone git@github.com:fsprojects/ProjectScaffold.git PaperScraper</code></pre>
<pre class="fsharp fragment"><code>→ cd PaperScraper &amp;&amp; ./build.sh</code></pre>
</section><section class="slide level2">

<p>Answer a couple of questions and you're set. But wait!</p>
</section><section class="slide level2">

<figure>
<img src="img/splonk.jpg" alt="" />
</figure>
</section><section class="slide level2">

<p><code>error : Target named 'Rebuild' not found in the project.</code></p>
</section><section class="slide level2">

<h4 id="a-note-about-build-targets">A Note About Build Targets</h4>
<p>Since in <em>NixOS</em> there is no(t one, but many) Global Assembly Cache, resolving default build targets shipped with <em>F#</em> does not work as expected.</p>
</section><section class="slide level2">

<p>The solution is to patch all <em>.fsproj</em> files in the solution and only conditionally set the <em>FSharpTargetsPath</em> if the target actually exists:</p>
<pre><code>- &lt;FSharpTargetsPath&gt;$(MSBuildExtensionsPath32)\Microsoft\VisualStudio...
+ &lt;FSharpTargetsPath Condition=&quot;Exists(&#39;$(MSBuildExtensionsPath32)\M...</code></pre>
</section><section class="slide level2">

<p>There is a package <em>nix</em> written by <em><span class="citation" data-cites="obadz_">@obadz_</span> which contains a script that finds and patches up </em>.fsproj_ files to look out for the <em>FSharpTargetsPath</em> enviroment variable.</p>
<p><code>→ nix-env -i dotnetbuildhelpers</code></p>
</section><section class="slide level2">

<h4 id="usage">Usage:</h4>
<pre><code>→ patch-fsharp-targets.sh
  Patching F# targets in fsproj files...
  ./src/PaperScraper/PaperScraper.fsproj
  ./tests/PaperScraper.Tests/PaperScraper.Tests.fsproj</code></pre>
</section><section class="slide level2">

<p>Last, we only need to set <em>FSharpTargetsPath</em> in our shell:</p>
<pre class="shell"><code>→ export FSharpTargetsPath=$(dirname $(which fsharpc))/../lib/mono/4.5/Microsoft.FSharp.Targets</code></pre>
<pre class="shell fragment"><code>→ set -x FSharpTargetsPath (dirname (which fsharpc))/../lib/mono/4.5/Microsoft.FSharp.Targets</code></pre>
<pre class="shell fragment"><code>{ config, pkgs, ... }:
{
  environment.variables.FSharpTargetsPath = &quot;${pkgs.fsharp}/lib/mono/4.5/Microsoft.FSharp.Targets&quot;;
}</code></pre>
</section><section class="slide level2">

<h4 id="hm-more-errors">Hm, More Errors</h4>
<p>Unfortuantely, more problems crop up at this point.</p>
<ul>
<li>FSharp.Core dll is missing when running tests, hence the build fails</li>
<li>FSharp.Core dll is missing when generating documentation, hence the build fails</li>
</ul>
<p>:(</p>
<aside class="notes">
<ul>
<li>mono crashes really hard running the tests</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="ah-yes">Ah yes!</h4>
<blockquote>
<p>&quot;In compiled applications, you should never assume that FSharp.Core is in the GAC (&quot;Global Assembly Cache&quot;). Instead, you should deploy the appropriate FSharp.Core as part of your application.&quot;</p>
</blockquote>
<p>https://fsharp.github.io/2015/04/18/fsharp-core-notes.html</p>
</section><section class="slide level2">

<h4 id="quick-fix">Quick Fix:</h4>
<p>Ship <em>FSharp.Core</em> as part of the build output and manage the dependency with <em>paket</em>.</p>
<pre class="fragment"><code>in paket.dependencies, add;

FSharp.Core = 4.0.0.1</code></pre>
<pre class="fragment"><code>in src/PaperScraper/paket.references, add:

FSharp.Core</code></pre>
<pre class="fragment"><code>&lt;Reference Include=&quot;FSharp.Core&quot;&gt;
  &lt;Private&gt;True&lt;/Private&gt;
  &lt;HintPath&gt;..\..\packages\FSharp.Core\lib\net40\FSharp.Core.dll&lt;/HintPath&gt;
&lt;/Reference&gt;</code></pre>
<aside class="notes">
<ul>
<li>add the FSharp.Core and verision to paket.dependencies</li>
<li>add the FSharp.Core to paket.references in the project and tests project</li>
<li>make sure to set TargetFSharpCoreVersion to the correct version!</li>
<li>execute paket install again</li>
<li>mono crashes really hard running the tests</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="a-better-fix">A Better™ Fix:</h4>
<p>It would be better to use the F# version shipped with NixOS.</p>
<pre class="fragment"><code>  &lt;TargetFSharpCoreVersion&gt;4.3.1.0&lt;/TargetFSharpCoreVersion&gt;</code></pre>
<pre class="fragment"><code>  &lt;Private&gt;True&lt;/Private&gt;
  &lt;HintPath&gt;$(TargetFSharpCorePath)&lt;/HintPath&gt;</code></pre>
<pre class="shell fragment"><code>→ set -x TargetFSharpCorePath (dirname (which fsharpc))/../lib/mono/4.5/FSharp.Core.dll</code></pre>
<pre class="shell fragment"><code>{ config, pkgs, ... }:
{
  environment.variables.TargetFSharpCorePath = &quot;${pkgs.fsharp}/lib/mono/4.5/FSharp.Core.dll&quot;;
}</code></pre>
<aside class="notes">
<ul>
<li>this is more general and robust</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="finding-the-correct-f-version">Finding the correct F# Version</h4>
<figure>
<img src="img/fsharp-versions.png" alt="" />
</figure>
<p>http://stackoverflow.com/questions/20332046/correct-version-of-fsharp-core</p>
</section><section class="slide level2">

<h4 id="documentation">Documentation?</h4>
<p>Both documentation and help targets don't build at this point as F# script files reference <em>DLLs</em> directly by path.</p>
</section><section class="slide level2">

<h4 id="but-were-building-an-executable-right">But we're building an executable, right?!</h4>
<p>The project template at this point generates a library project by default, so the <em>.fsproj</em> file needs to be amended in 2 ways:</p>
<pre class="fragment"><code>    &lt;OutputType&gt;Exe&lt;/OutputType&gt;</code></pre>
<pre class="fragment"><code>    &lt;ErrorReport&gt;prompt&lt;/ErrorReport&gt;
    &lt;Externalconsole&gt;true&lt;/Externalconsole&gt;</code></pre>
</section><section class="slide level2">

<p>Additionally, the tests project also holds a reference to the current project, so we need to comment it and the code in <em>Tests.fs</em> out to ensure a clean build.</p>
<aside class="notes">

</aside>
</section><section id="phew" class="slide level2">
<h1>Phew!</h1>
<figure>
<img src="img/phew.png" alt="" />
</figure>
</section><section id="recoll" class="slide level2">
<h1>Recoll</h1>
</section><section class="slide level2">

<ul>
<li class="fragment">full-text search tool</li>
<li class="fragment">uses xapian underneath (like other great tools, e.g. <code>notmuch</code> and <code>mu</code>)</li>
<li class="fragment">extensible and configurable</li>
<li class="fragment">supports indexing many mime types, including extracting text from PDFs</li>
<li class="fragment">has a flexible query language (based on Xesam)</li>
<li class="fragment">needs to be configured correctly (whitelist directories)</li>
<li class="fragment">the indexer needs to be run in a cron/systemd timer job</li>
</ul>
</section><section class="slide level2">

<h4 id="an-example">An Example</h4>
<pre><code>➜  recoll -t -n 1 -m -q burrito
Recoll query: ((burrito:(wqf=11) OR burritos))
5 results (printing  1 max):
application/pdf [file:///home/k/doc/books/burrito_monads.pdf]   [burrito_monads.pdf]    74745   bytes   
abstract =   Burritos for the Hungry Mathematician Ed Morehouse April 1, 2015 Abstract The advent of fast-casual Mexican-style dining establishments, such as Chipotle and Qdoba, has greatly improved the productivity of research mathematicians and theoretical
author = LaTeX with hyperref package
dbytes = 10425
fbytes = 74745
filename = burrito_monads.pdf
fmtime = 01445444345
mtime = 01445444345
mtype = application/pdf
origcharset = UTF-8
pcbytes = 74745
rcludi = /home/k/doc/books/burrito_monads.pdf|
relevancyrating = 100%
sig = 747451445444345
title = 
url = file:///home/k/doc/books/burrito_monads.pdf</code></pre>
</section><section class="slide level2">

<h4 id="search-for-file-names">Search For File Names</h4>
<pre><code>➜  recoll -t -n 1 -f burrito
Recoll query: (XSFSburrito_monads.pdf)
1 results
application/pdf [file:///home/k/doc/books/burrito_monads.pdf]   [burrito_monads.pdf]    74745   bytes   </code></pre>
</section><section id="so-parsing-anyone" class="slide level2">
<h1>So, parsing anyone?</h1>
</section><section id="fparsec-to-the-rescue" class="slide level2">
<h1>FParsec to the rescue!</h1>
<ul>
<li class="fragment">I ♥ parsers</li>
</ul>
</section><section class="slide level2">

<ul>
<li class="fragment">parser-combinator libary modeled after Parsec</li>
<li class="fragment">a Parser is a function from some input to a possible result</li>
</ul>
<pre class="fragment"><code>type Parser&lt;&#39;a, &#39;u&gt; = CharStream&lt;&#39;u&gt; -&gt; Reply&lt;&#39;a&gt;</code></pre>
<ul>
<li class="fragment">combinators (higher-order functions) compose to form new parsers</li>
<li class="fragment">conditional parsers (&lt;|&gt;)</li>
<li class="fragment">lookahead parsers that don't consume the input</li>
<li class="fragment">FIXME: some more examples?</li>
</ul>
</section><section class="slide level2">

<h4 id="k-words-worth-of-examples">1k words worth of examples:</h4>
<pre class="fragment"><code>// a function to narrow down the selection of admissible characters

let plainChar (c : char) = 
  let chars = [&#39;a&#39;..&#39;z&#39;]
  let pred c&#39; = c&#39; = c 
  match List.tryFind pred chars with
    | Some(_) -&gt; true
    | _       -&gt; false</code></pre>
<pre class="fragment"><code>// now use our char-validator to explain that we&#39;re interested in _many_ matches

let plainChars : Parser&lt;string, unit&gt; = 
  manySatisfy plainChar</code></pre>
<aside class="notes">
<ul>
<li>there is a more concise way to do this, but it its a good example nonetheless</li>
</ul>
</aside>
</section><section class="slide level2">

<p>A mime-type string as seen in our output is a sequence of plain characters separated by a slash, followed by some more plain characters.</p>
<pre><code>application/pdf ....</code></pre>
<pre class="fragment"><code>let mimeType : Parser&lt;string, unit&gt; =
  plainChars  &gt;&gt;= fun res1 -&gt;
  pstring &quot;/&quot; &gt;&gt;= fun _    -&gt;
  plainChars  &gt;&gt;= fun res2 -&gt;
  preturn (res1+&quot;/&quot;+res2)</code></pre>
<div notes="class">
<ul>
<li>this is not actually a valid media type parser at all</li>
<li>there are media types with +.- and numbers</li>
<li>good enough for now</li>
</ul>
</div>
</section><section id="defining-the-models" class="slide level2">
<h1>Defining The Models</h1>
</section><section class="slide level2">

<h4 id="a-query-result">A query result:</h4>
<ul>
<li class="fragment">begins with the query issued, followed by</li>
<li class="fragment">a line containing the number of matching items, followed by</li>
<li class="fragment">none or many results</li>
</ul>
</section><section class="slide level2">

<h4 id="a-result-row">A Result &quot;Row&quot;:</h4>
<ul>
<li class="fragment">begins with an abstract, eventually followed by a</li>
<li class="fragment">file name line, eventually followed by a</li>
<li class="fragment">mime type line, eventually followed by a</li>
<li class="fragment">character set line, eventually followed by a</li>
<li class="fragment">url line</li>
</ul>
<aside class="notes">
<ul>
<li>only interested in a few fields</li>
<li>parser needs to test and skip ahead to the next relevant line</li>
<li>expects at least this set of lines in this order</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="queryresult">QueryResult:</h4>
<pre class="fsharp"><code>type QueryResult =
  { Query : QueryString // alias for `string`
  ; Count : int64
  ; Rows  : Row array
  }
  with
    static member empty =
      { Query = &quot;&quot;
      ; Count = 0L
      ; Rows  = Array.empty
      }</code></pre>
</section><section class="slide level2">

<h4 id="result-row">Result Row:</h4>
<pre class="fsharp"><code>type Row =
  { Abstract : string
  ; FileName : FileName
  ; MimeType : MimeType
  ; CharSet  : CharSet
  ; Url      : Url
  }</code></pre>
</section><section class="slide level2">

<h4 id="query-line">Query Line:</h4>
<pre class="fsharp"><code>let queryLine : Parser&lt;string, unit&gt; =
  pstring &quot;Recoll query:&quot; &gt;&gt;. restOfLine true</code></pre>
</section><section class="slide level2">

<h4 id="count-line">Count line</h4>
<pre class="fsharp"><code>let totalLine : Parser&lt;int64, unit&gt; =
  pint64 .&gt;&gt; skipRestOfLine consume</code></pre>
<aside class="notes">
<ul>
<li>not using -n to restrict num rows so parser is simple</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="result-row-1">Result Row:</h4>
<pre class="fsharp"><code>let abstractLine : Parser&lt;string, unit&gt; =
  pstring &quot;abstract = &quot; &gt;&gt;. restOfLine true
</code></pre>
<pre class="fsharp fragment"><code>let filenameLine : Parser&lt;FileName, unit&gt; =
  pstring &quot;filename = &quot; &gt;&gt;. restOfLine true
  </code></pre>
<pre class="fsharp fragment"><code>let mtypeLine : Parser&lt;MimeType, unit&gt; =
  pstring &quot;mtype = &quot; &gt;&gt;. mimeType .&gt;&gt; skipRestOfLine consume</code></pre>
</section><section class="slide level2">

<pre class="fsharp"><code>// a little example of `active patters`

let (|CharSetLit|_|) (prefix : string) (str : string) =
  if str.StartsWith(prefix)
  then Some(str.Substring(prefix.Length))
  else None

let charsetLine : Parser&lt;CharSet,unit&gt; =
  pstring &quot;origcharset = &quot; &gt;&gt;. 
  restOfLine consume &gt;&gt;= fun str -&gt;
    match str with
      | CharSetLit &quot;UTF-8&quot; _  -&gt; UTF8
      | CharSetLit &quot;UTF-16&quot; _ -&gt; UTF16
      | s                     -&gt; UnknownCharset s
    |&gt; preturn
    .&gt;&gt; skipRestOfLine consume</code></pre>
</section><section class="slide level2">

<pre class="fsharp"><code>let urlLine : Parser&lt;Url, unit&gt; =
  pstring &quot;url = &quot; &gt;&gt;. restOfLine consume</code></pre>
<pre class="fsharp fragment"><code>// skip ahead to the next matching line
let skipTo p =
  skipManyTill (restOfLine true) (lookAhead p) &gt;&gt;. p</code></pre>
</section><section class="slide level2">

<h4 id="putting-it-all-together">Putting it all together</h4>
<pre class="fsharp fragment"><code>let searchResult : Parser&lt;Row, unit&gt; =
  (skipTo abstractLine) &gt;&gt;= fun a -&gt;
  (skipTo filenameLine) &gt;&gt;= fun f -&gt;
  (skipTo mtypeLine)    &gt;&gt;= fun m -&gt;
  (skipTo charsetLine)  &gt;&gt;= fun c -&gt;
  (skipTo urlLine)      &gt;&gt;= fun u -&gt;
  preturn { Abstract = a
          ; FileName = f
          ; MimeType = m
          ; CharSet  = c
          ; Url      = u }</code></pre>
</section><section class="slide level2">

<h4 id="better">Better™!</h4>
<pre class="fsharp fragment"><code>let searchResult : Parser&lt;Row,unit&gt; =
  pipe5 (skipTo abstractLine)
        (skipTo filenameLine)
        (skipTo mtypeLine)
        (skipTo charsetLine)
        (skipTo urlLine)
        mkRow // where mkRow is simply a function that constructs the value (lifting is automatic)</code></pre>
</section><section class="slide level2">

<h4 id="the-final-parser">The Final Parser:</h4>
<pre class="fsharp fragment"><code>let recollOutput : Parser&lt;QueryResult, unit&gt; =
  queryLine &gt;&gt;= fun q -&gt;
  totalLine &gt;&gt;= fun c -&gt;
  (parray (int(c)) searchResult) &gt;&gt;= fun rows -&gt;  // we know the number of results!
  preturn (mkResult q c rows)</code></pre>
<aside class="notes">
<ul>
<li>parray is easiest and clean in this case</li>
<li><code>many</code> might also work</li>
<li>interrupt the backtracking loop</li>
</ul>
</aside>
</section><section class="slide level2">

<h4 id="testing-the-parser">Testing The Parser</h4>
<pre class="fsharp"><code>let parseOutput str =
  match run recollOutput str with
    | Success(res, _, _) -&gt; res
    | Failure(msg, _, _) -&gt; failwith msg</code></pre>
</section><section class="slide level2">

<h4 id="using-the-real-thing">Using The Real Thing</h4>
<pre class="fsharp"><code>let queryRecoll term =
  let binpath = &quot;/run/current-system/sw/bin/recoll&quot;
  let raw = executeProcess (binpath, sprintf &quot;-t -o -m -q %s&quot; term)
  if fst raw = 0
  then parseOutput (snd raw)
  else failwith &quot;running recoll failed&quot;</code></pre>
</section><section id="hooray" class="slide level2">
<h1>HOORAY!</h1>
<figure>
<img src="img/wabbit.gif" alt="" />
</figure>
</section><section id="suave.io" class="slide level2">
<h1>Suave.IO</h1>
<blockquote>
<p>Suave is a simple web development F# library providing a lightweight web server and a set of combinators to manipulate route flow and task composition.</p>
</blockquote>
<p>http://suave.io</p>
</section><section class="slide level2">

<h4 id="features">Features:</h4>
<ul>
<li class="fragment">combinators for request routing</li>
<li class="fragment">built-in web-server</li>
<li class="fragment">openssl support</li>
</ul>
</section><section class="slide level2">

<h5 id="the-simplest-possible-application">The Simplest Possible Application:</h5>
<p><code>startWebServer defaultConfig (OK &quot;Hi.&quot;)</code></p>
</section><section class="slide level2">

<h5 id="more-elaborate-example">More Elaborate Example</h5>
<pre><code>open Suave
open Suave.Http
open Suave.Http.Applicatives
open Suave.Http.Successful
open Suave.Web

let serarch q =
  defaultArg (Option.ofChoice(q ^^ &quot;filename&quot;)) &quot;nothing&quot; |&gt; sprintf &quot;Found %s.&quot;

let app : WebPart =
    path &quot;/search&quot; &gt;&gt;= 
      GET  &gt;&gt;= request(fun r -&gt; OK &lt;| search r.query)
      RequestErrors.NOT_FOUND &quot;Found no handlers&quot; ]

startWebServer defaultConfig app</code></pre>
<aside class="notes">
<ul>
<li>match GET requests on <code>/search</code> endpoint</li>
<li>return a 404 for all other routes (even <code>/</code>)</li>
</ul>
</aside>
</section><section class="slide level2">

<h5 id="types-1">Types</h5>
<pre><code>type SuaveTask&lt;&#39;a&gt; = Async&lt;&#39;a option&gt;
type WebPart = HttpContext -&gt; SuaveTask&lt;HttpContext&gt;
// hence: WebPart = HttpContext -&gt; Async&lt;HttpContext option&gt;</code></pre>
</section><section id="pulling-it-all-together" class="slide level2">
<h1>Pulling It All Together</h1>
<p>We need to:</p>
<ol type="1">
<li class="fragment">create data types (domain model)</li>
<li class="fragment">write a simple parser for <em>recoll</em> output</li>
<li class="fragment">map HTTP query to command-line arguments</li>
<li class="fragment">serialiation of results to JSON</li>
</ol>
</section><section class="slide level2">

<h4 id="dependencies">Dependencies</h4>
<p>Add Suave and FParsec to <em>paket.depenecies</em> and <em>src/PaperScraper/paket.references</em>:</p>
<pre><code>source https://nuget.org/api/v2

nuget FSharp.Formatting
nuget NUnit 
nuget NUnit.Runners
nuget FAKE
nuget SourceLink.Fake

nuget Suave
nuget FParsec

github fsharp/FAKE modules/Octokit/Octokit.fsx</code></pre>
</section><section class="slide level2">

<p>Contents of <em>paket.references</em>:</p>
<pre><code>Suave
FParsec</code></pre>
</section><section class="slide level2">

<h5 id="a-little-tooling">A little Tooling</h5>
<pre class="fsharp fragment"><code>#r @&quot;../../packages/Suave/lib/net40/Suave.dll&quot;
#r @&quot;../../packages/FParsec/lib/net40-client/FParsecCS.dll&quot;
#r @&quot;../../packages/FParsec/lib/net40-client/FParsec.dll&quot;

#load @&quot;Types.fs&quot;
#load @&quot;Recoll.fs&quot;</code></pre>
<pre class="shell fragment"><code>➜ cd src/PaperScraper
➜ fsharpi --load:script.fsx</code></pre>
<aside class="notes">
<ul>
<li>fsharpi is currently not aware of projects so this is userful to load the environment</li>
<li>other than that I miss <code>:type</code> from ghci <em>a lot</em></li>
</ul>
</aside>
</section><section class="slide level2">

<h5 id="basic-types">Basic Types</h5>
<p>TODO: WORK IT OUT!!!</p>
<pre class="fsharp fragment"><code>type MimeType = string
type FileName = string

type CharSet =
  | UTF8
  | Other // how ignorant of me ;)

type Percentage = int

type Url = string

type Bytes = int

type SearchResult =
  { Abstract  : string
  ; FileName  : FileName
  ; MimeType  : MimeType
  ; CharSet   : CharSet
  ; Relevance : Percentage
  ; Title     : string option
  ; Url       : Url
  ; FileSize  : Bytes
  }</code></pre>
</section><section class="slide level2">

<h5 id="parsing-recoll-output">Parsing Recoll Output</h5>
<p>TODO: insert parser code</p>
</section><section class="slide level2">

<h5 id="querying-recoll">Querying Recoll</h5>
<p>TODO: insert query code</p>
</section><section class="slide level2">

<h5 id="section"></h5>
</section></section>
<section><section id="deployment" class="titleslide slide level1"><h1>Deployment</h1></section><h4 id="deployment-1">Deployment</h4><section class="slide level2">

<h4 id="creating-a-package">Creating A Package*</h4>
<p>(* or Derivation in Nix-lingo)</p>
</section><section class="slide level2">

<h4 id="the-impure-way">The <em>Impure</em> way</h4>
<pre><code>with import &lt;nixpkgs&gt; {};
with lib;


stdenv.mkDerivation {
  name = &quot;paperscraper-$version&quot;;

  version = &quot;0.0.1&quot;;

  src = fetchurl {
    url = &quot;https://github.com/krgn/PaperScraper/tarball/6a8e0d29c90844fa18665278f5dd1fb96537d70&quot;;
    sha256 = &quot;0l2jchn4p9bj157h94l6gi8ca3hafyacx5809nv9ssvhlk00ps87&quot;;
  };

  buildInputs = [ fsharp mono curl strace ];

  phases = [ &quot;unpackPhase&quot; &quot;buildPhase&quot; &quot;installPhase&quot; ];

  buildPhase = &#39;&#39;
    patchShebangs .
    build.sh
  &#39;&#39;;

  installPhase = &#39;&#39;
    mkdir -p &quot;$out/bin&quot; &quot;$out/lib/mono/packages/$name&quot;

    cp -r &quot;bin/PaperScraper&quot; &quot;$out/lib/mono/packages/$name/&quot;

    cat &gt;&gt; &quot;$out/bin/PaperScraper&quot; &lt;&lt;-WRAPPER
    #!/bin/sh
    ${mono}/bin/mono $out/lib/PaperScraper/PaperScraper.exe
    WRAPPER

    chmod +x &quot;$out/bin/PaperScraper&quot;
  &#39;&#39;;

  meta = {
    description = &quot;its a service!&quot;;
    homepage = &quot;https://github.com/krgn/PaperScraper&quot;;
  };
}</code></pre>
</section><section class="slide level2">

<p>Install it!</p>
<pre><code>$ nix-env -i -f paperscraper.nix</code></pre>
</section><section id="oh-no" class="slide level2">
<h1>OH NO!</h1>
</section><section id="of-course-in-nix-clocks-tick-differently." class="slide level2">
<h1>Of course! In Nix, clocks tick differently.</h1>
<aside class="notes">
<ul>
<li>there is resolv.conf in the chroot/sandbox, so no network</li>
<li>no paket and no nuget</li>
<li>tl;dr it doestn't work</li>
</ul>
</aside>
</section><section id="the-solution" class="slide level2">
<h1>THE SOLUTION</h1>
<ul>
<li class="fragment">lift nuget packages into the store</li>
<li class="fragment">link packages into the packages directory</li>
</ul>
</section><section id="introducint-paket2nix" class="slide level2">
<h1>INTRODUCINT PAKET2NIX</h1>
</section><section id="nix-yfying-the-project" class="slide level2">
<h1>NIX-YFYING THE PROJECT</h1>
<pre><code>cd /path/to/project/
Paket2Nix</code></pre>
<p>Thats it. The <code>nix</code> directory now contains a top-level expression <code>top.nix</code> which you can use to build the package and all other expressions.</p>
</section><section id="building" class="slide level2">
<h1>BUILDING</h1>
<pre><code>➜  nix git:(master) ✗ nix-build top.nix -A PaperScraper</code></pre>
<p>will at this point produce:</p>
<pre><code>➜  nix git:(master) ✗ nix-build top.nix -A PaperScraper

/nix/store/328ccq2dw1dq8i0dlmlzf0iknb1pad28-paperscraper-0.0.1</code></pre>
<p>which we can install into our environment</p>
<pre><code>➜  nix git:(master) ✗ nix-env -i -f ./top.nix -A PaperScraper
replacing old ‘paperscraper-0.0.1’
installing ‘paperscraper-0.0.1’
building path(s) ‘/nix/store/0d4vh1vaw41v3xn9vq66yydck142z02d-user-environment’
created 19003 symlinks in user environment</code></pre>
</section><section id="deploying-system-wide" class="slide level2">
<h1>Deploying system-wide</h1>
</section><section id="mention-hydra" class="slide level2">
<h1>mention hydra</h1>
</section><section id="package-up-our-expressions" class="slide level2">
<h1>package up our expressions</h1>
<p><code>echo &quot;import ./top.nix&quot; &gt;&gt; nix/default.nix    tar cjvf nixexprs.tar.bz2 nix/    mkdir -p ~/tmp/mycache    mv nixexprs.tar.bz2 ~/tmp/mycache</code></p>
</section><section id="create-a-simple-cache-for-our-expressions" class="slide level2">
<h1>create a simple cache for our expressions</h1>
<p><code>cd ~/tmp/mycache    nix-push --dest . --manifest /nix/store/328ccq2dw1dq8i0dlmlzf0iknb1pad28-paperscraper-0.0.1/</code> creates a binary cache of all expressions</p>
</section><section id="using-the-channel" class="slide level2">
<h1>using the channel</h1>
<p>``` nix-channel --add file:///home/k/tmp/mycache krgn nix-channel --update</p>
<p>nix-env -qaP | grep -i PaperScraper krgn.PaperScraper paperscraper-0.0.1 ``` ## creating a custom module</p>
<pre><code>{config, pkgs, lib, ...}:

let
  cfg = config.services.paperscraper;
  krgn = import &lt;krgn&gt;;
in

with lib;

{
  options = {
    services.paperscraper = {
      enable = mkOption {
        default = false;
        type = with types; bool;
        description = &#39;&#39;
          Start the PaperScraper API service.
        &#39;&#39;;
      };

      user = mkOption {
        default = &quot;username&quot;;
        type = with types; uniq string;
        description = &#39;&#39;
          Name of the user to run as.
        &#39;&#39;;
      };
    };
  };

  config = mkIf cfg.enable {
    jobs.paperscraper = {
      description = &quot;Start the paperscraper service.&quot;;
      startOn = &quot;started network-interfaces&quot;;
      exec = &#39;&#39;/var/setuid-wrappers/sudo -u ${cfg.user} -- ${krgn.PaperScraper}/bin/PaperScraper&#39;&#39;;
    };

    environment.systemPackages = [ krgn.PaperScraper pkgs.recoll ];
  };
}</code></pre>
<p>and import this in <code>configuration.nix</code></p>
<pre><code>imports = [
   ./services/paperscraper.nix
  ]
  
...
services.paperscraper = {
  enable = true;
  user = &quot;k&quot;;
};</code></pre>
</section></section>
<section><section id="useful-resources" class="titleslide slide level1"><h1>Useful resources</h1></section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Vertical centering of slides
        center: true,

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
